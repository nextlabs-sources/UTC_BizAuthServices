package com.nextlabs.ac;import java.text.MessageFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.Properties;import java.util.StringTokenizer;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import com.bluejungle.framework.expressions.EvalValue;import com.bluejungle.framework.expressions.IEvalValue;import com.bluejungle.framework.expressions.IMultivalue;import com.bluejungle.framework.expressions.Multivalue;import com.bluejungle.framework.expressions.ValueType;import com.bluejungle.framework.utils.StringUtils;import com.bluejungle.pf.domain.destiny.serviceprovider.IFunctionServiceProvider;import com.bluejungle.pf.domain.destiny.serviceprovider.ServiceProviderException;import com.nextlabs.ac.helper.ACConstants;import com.nextlabs.ac.helper.HSQLHelper;import com.nextlabs.ac.helper.IOHelper;import com.nextlabs.ac.helper.PropertyLoader;import com.nextlabs.ac.helper.QueryBuilder;public class AuthorityService implements IFunctionServiceProvider {	private static final Log LOG = LogFactory.getLog(AuthorityService.class);	private static Properties prop = PropertyLoader	.loadProperties(ACConstants.COMMON_AC_PROPFILE);	private static HSQLHelper hsqlHelper;	// UTC test Case 5: Bug fix start	private static IEvalValue emptySet = EvalValue.build(Multivalue.EMPTY);	// UTC test Case 5: Bug fix end	private final static String COUNTARGUMENT = MessageFormat.format(	"COUNT(DISTINCT({0}))", prop.getProperty("au_col_AuthorityId"));	private final static String INTERNALLICENSEARGUMENT = MessageFormat.format(	"DISTINCT({0})", prop.getProperty("au_col_InternalLicenseNo"));	private final static String LICENSEARGUMENT = MessageFormat.format(	"DISTINCT({0})", prop.getProperty("au_col_AuthorityId"));	private final static String CCLCOUNTRY = MessageFormat.format(	"DISTINCT({0}.{1})", prop.getProperty("alias_actm"),	prop.getProperty("actm_col_CountryCode"));	private final static String LIC = "lic_authority_type";	private final static String CCL = "ccl_authority_type";	private static String LICENSESTATUS;	private static String LICENSESQLOPERATOR;	private String custom_logging_path;	private String env_reqid = null;	/*	 * 	 * global default values which has to be assigned during the initiation of	 * 	 * the service	 */	public void init() throws Exception {		LOG.debug("AuthorityService init() started.");		if (null != prop) {			hsqlHelper = new HSQLHelper(prop.getProperty("hsql_server_url"),					prop.getProperty("hsql_user_name"),					prop.getProperty("hsql_password"), Integer.parseInt(prop							.getProperty("hsql_connectionpool_size")));			setLicenseStatus();			custom_logging_path = prop.getProperty("custom_logging_path");			if (!custom_logging_path.endsWith("\\")) {				custom_logging_path += "\\";			}		}		LOG.debug("AuthorityService init() completed.");	}	/*	 * This method help to load the license status from properites. The License	 * status SQL operator is decided by the LicenseStatus values.	 */	private void setLicenseStatus() {		String licenseStatusVals = prop.getProperty("license_status_active");		String licenseStatusSepr = prop.getProperty("license_status_separator");		if (licenseStatusVals != null && licenseStatusSepr != null) {			StringTokenizer strToken = new StringTokenizer(licenseStatusVals,					licenseStatusSepr);			if (strToken.countTokens() == 1) {				LICENSESQLOPERATOR = "=";				LICENSESTATUS = "'" + strToken.nextToken().trim().toLowerCase()						+ "'";			} else if (strToken.countTokens() > 1) {				LICENSESQLOPERATOR = "IN";				StringBuilder sb = new StringBuilder("(");				while (strToken.hasMoreTokens()) {					sb.append("'");					sb.append(strToken.nextToken().trim().toLowerCase());					sb.append("'");					if (strToken.hasMoreTokens()) {						sb.append(",");					}				}				sb.append(")");				LICENSESTATUS = sb.toString();			}		}		LOG.info("LICENSESQLOPERATOR:" + LICENSESQLOPERATOR);		LOG.info("LICENSESTATUS:" + LICENSESTATUS);	}	/*	 * 	 * This is a main call function called by the policy controller through	 * 	 * advanced condition.It checks for the valid methods and pass the control	 * 	 * flow to the correct methods.	 */	public IEvalValue callFunction(String functionName, IEvalValue[] args)	throws ServiceProviderException {		IEvalValue result = emptySet;		try {			LOG.debug("AuthorityService callfunction() started, with function: "					+ functionName);			long lCurrentTime = System.nanoTime();			// LOG.info("Thread Local : "+UserService.userObject.get());			if ("getLicenseNos".equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, false, LICENSEARGUMENT);			} else if ("getCount".equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, false, COUNTARGUMENT);				result = processResult(result);			} else if ("getInternalLicenseNos".equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, false, INTERNALLICENSEARGUMENT);			} else if ("getValidLicenseNos".equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, true, LICENSEARGUMENT);			} else if ("getValidCount".equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, true, COUNTARGUMENT);				result = processResult(result);			} else if ("getValidInternalLicenseNos"					.equalsIgnoreCase(functionName)) {				result = getLicenseNos(args, true, INTERNALLICENSEARGUMENT);			} else if ("getCCLCountries".equalsIgnoreCase(functionName)) {				result = getCCLCountries(args);			}			LOG.debug("AuthorityService callfunction() completed. Result: "					+ result.toString() + " Time spent: "					+ ((System.nanoTime() - lCurrentTime) / 1000000.00) + "ms");		} catch (Exception e) {			LOG.error("AuthorityService callfunction() error: ", e);			result = emptySet;		}		return result;	}	/*	 * This method helps to process the result for getting the count. So that	 * the count method specifically returns as zero.	 */	private IEvalValue processResult(IEvalValue result) {		if (result == emptySet) {			return EvalValue.build(0);		} else {			return result;		}	}	/*	 * 	 * This method fetches the list of ccl countries which were restricted based	 * 	 * on the classification and jurisdiction. reason for control is an optional	 * 	 * parameters.	 */	private IEvalValue getCCLCountries(IEvalValue[] sColumn) {		LOG.debug("AuthorityService getCCLCountries() called.");		LOG.debug("AuthorityService getCCLCountries() sColumn.length : "		+ sColumn.length);		if (sColumn.length < 2) {			LOG.warn("Wrong number of parameters.");			return emptySet;		}		ArrayList<String> sArrDataInput = processValues(sColumn);		if (sArrDataInput.size() < 2)			{			LOG.warn("Wrong number of parameters.");			return emptySet;			}		ArrayList<String> sArrList = new ArrayList<String>();		if (sArrDataInput.size() == 2) {			Object[] tcArgs = { prop.getProperty("alias_jcm"),			prop.getProperty("jcm_col_Jurisdiction"),			prop.getProperty("jcm_col_Classification"),			prop.getProperty("alias_actm"),			prop.getProperty("actm_col_CCLFlag"),			prop.getProperty("cclflag_restricted") };			sArrList.add(MessageFormat					.format(					" LCASE(TRIM({0}.{1}))=LCASE(TRIM(?)) AND LCASE(TRIM({0}.{2}))=LCASE(TRIM(?)) AND LCASE(TRIM({3}.{4}))=LCASE(TRIM(''''{5}'''')) ",							tcArgs));			sArrList.addAll(sArrDataInput);		} else if (sArrDataInput.size() == 3) {			Object[] tcArgs = { prop.getProperty("alias_jcm"),			prop.getProperty("jcm_col_Jurisdiction"),			prop.getProperty("jcm_col_Classification"),			prop.getProperty("alias_actm"),			prop.getProperty("actm_col_CCLFlag"),			prop.getProperty("actm_col_ReasonForControl"),			prop.getProperty("cclflag_restricted") };			sArrList.add(MessageFormat					.format(					" LCASE(TRIM({0}.{1}))=LCASE(TRIM(?)) AND LCASE(TRIM({0}.{2}))=LCASE(TRIM(?)) AND LCASE(TRIM({3}.{4}))=LCASE(TRIM(''''{6}'''')) AND LCASE(TRIM({3}.{5}))=LCASE(TRIM(?)) ",					tcArgs));			sArrList.addAll(sArrDataInput);		}		LOG.debug("AuthorityService sArrList : " + sArrList);		LOG.debug("AuthorityService sArrList.size() : " + sArrList.size());		ArrayList<String> cclCountries = retrieveDataFromDB(sArrList,				CCLCOUNTRY,				false, CCL);		LOG.debug(" AuthorityService CountryCode " + cclCountries);		// Unit test case 5 : Bug Fix Start		IEvalValue evalue = emptySet;		if (cclCountries != null)			evalue = prepareLicenses(cclCountries);		// Unit test case 5 : Bug Fix End		return evalue;	}	/*	 * 	 * Get the LicenseNos(authorityIds) based on the predicates passed by the	 * 	 * policy. if valid flag is true returns only active licenses else returns	 * 	 * both active and inactive licenses. This single method returns the	 * 	 * count,internal licensenos and authority ids based on the coloumnargument.	 */	private IEvalValue getLicenseNos(IEvalValue[] sColumn, boolean validFlag,			String columnArgument) {		LOG.debug("AuthorityService getLicenseNos() called.");		LOG.debug("AuthorityService getLicenseNos() sColumn.length : "				+ sColumn.length);		if (sColumn.length < 2) {			LOG.error("Wrong number of parameters.");			return emptySet;		}		ArrayList<String> sArrDataInput = processValues(sColumn);		try {			int qc = StringUtils.count(sArrDataInput.get(0), '?');			if (sArrDataInput.size() - 1 == qc) {				LOG.info("Inputs are valid");			} else if (sArrDataInput.size() - 2 == qc) {				env_reqid = sArrDataInput.remove(sArrDataInput.size() - 1);				Long.parseLong(env_reqid);// For validating whether the last											// parameter is request id			} else {				LOG.warn("Inputs are not valid");				return emptySet;			}		} catch (NumberFormatException e) {			LOG.warn("The number of arguments in the predicate is not matching with no parameters");			return emptySet;		} catch (Exception e) {			LOG.error("AuthorityService:Inputs are not valid: ", e);			return emptySet;		}		LOG.debug("AuthorityService sArrDataInput : " + sArrDataInput);		LOG.debug("AuthorityService sArrDataInput.size() : "				+ sArrDataInput.size());		sArrDataInput = addLcase(sArrDataInput);		ArrayList<String> licenses = null;		if (LICENSEARGUMENT.equals(columnArgument))			licenses = retrieveDataFromDB(sArrDataInput, columnArgument,					validFlag, LIC);		else			licenses = retrieveDataFromDB(sArrDataInput,					INTERNALLICENSEARGUMENT, validFlag, LIC);		LOG.debug(" AuthorityService Licenses " + licenses);		// Unit test case 5 : Bug Fix Start		IEvalValue evalue = emptySet;		if (licenses != null) {			if (columnArgument.equals(COUNTARGUMENT)) {				evalue = EvalValue.build(licenses.size());			} else {				evalue = prepareLicenses(licenses);			}		}		if (env_reqid != null && hsqlHelper != null				&& custom_logging_path != null && licenses != null) {			IOHelper ioh = new IOHelper();			String query = "SELECT {0} FROM {1} WHERE {2}='{0}'";			Object[] args = { prop.getProperty("au_col_InternalLicenseNo"),					prop.getProperty("table_au"),					prop.getProperty("au_col_AuthorityId") };			ioh.setQuery(MessageFormat.format(query, args));			ioh.setHelper(hsqlHelper);			ioh.setPath(custom_logging_path);			ioh.setEnv_id(env_reqid);			ioh.setLicenses(licenses);			if (LICENSEARGUMENT.equals(columnArgument))				ioh.setAuthorityNeeded(true);			//ioh.start();			LOG.info("Thread called to log the license in a file");		}		// Unit test case 5 : Bug Fix End		return evalue;	}	/*	 * 	 * Validating the input whether the app has send equal no of arguments for	 * 	 * the parameters in the parameterized query.	 */	private ArrayList<String> addLcase(ArrayList<String> sArrDataInput) {		Iterator<String> iter = sArrDataInput.iterator();		ArrayList<String> result = new ArrayList<String>();		HashSet<String> fieldnames = new HashSet<String>();		fieldnames.add(prop.getProperty("au.Scope"));		fieldnames.add(prop.getProperty("au.Sme"));		fieldnames.add(prop.getProperty("au.Platform"));		fieldnames.add(prop.getProperty("au.Model"));		fieldnames.add(prop.getProperty("aim.ItemNo"));		fieldnames.add(prop.getProperty("acm.Characteristic"));		fieldnames.add(prop.getProperty("jcm.Jurisdiction"));		fieldnames.add(prop.getProperty("jcm.Classification"));		fieldnames.add(prop.getProperty("actm.CountryCode"));		fieldnames.add(prop.getProperty("afsm.ForeignConsignee"));		fieldnames.add(prop.getProperty("aaum.WindowsSID"));		fieldnames.add(prop.getProperty("aaum.UserId"));		fieldnames.add(prop.getProperty("arm.Resource"));		fieldnames.add(prop.getProperty("au.InternalLicenseNo"));		LOG.info("fieldnames to be checked for case insensitive" + fieldnames);		if (iter.hasNext()) {			String predicate = iter.next();			for (String field : fieldnames) {				if (field != null) {					if (predicate.contains(field)) {						predicate = predicate.replace(field, "LCASE(TRIM("								+ field + "))");					}				}			}			predicate = predicate.replace("(?)", "#$%");			predicate = predicate.replace("?", "LCASE(TRIM(?))");			predicate = predicate.replace("#$%", "(?)");			result.add(predicate);			while (iter.hasNext()) {				result.add(iter.next().toLowerCase());			}		}		return result;	}	private boolean validateInput(ArrayList<String> sArrDataInput) {		try {			int qc = StringUtils.count(sArrDataInput.get(0), '?');			if (sArrDataInput.size() - 1 == qc) {				return true;			}			else {				return false;			}		} catch (Exception e) {			LOG.error("AuthorityService validateInput() error: ", e);			return false;		}	}	/*	 * 	 * This method takes a arraylist of string and returns a IEvalValue	 */	protected IEvalValue prepareLicenses(ArrayList<String> licenses) {		IEvalValue result = null;		if (licenses != null && licenses.size() > 0) {			/*			 * ArrayList<IEvalValue> evs = new ArrayList<IEvalValue>();			 * 			 * for (String license : licenses) {			 * 			 * IEvalValue value = EvalValue.build(license);			 * 			 * evs.add(value);			 * 			 * }			 */			IMultivalue imv = Multivalue.create(licenses, ValueType.STRING);			result = EvalValue.build(imv);		} else {			return emptySet;		}		return result;	}	/*	 * 	 * This method calls the database to retrieve the Licenses	 */	private ArrayList<String> retrieveDataFromDB(	ArrayList<String> sArrDataInput, String projColumn,	boolean validFlag, String authorityType) {		LOG.debug("AuthorityService retrieveLicenses() called.");		return hsqlHelper.retrieveLicenses(prepareQueryforLicenses(		sArrDataInput, projColumn, validFlag, authorityType));	}	/*	 * 	 * This method prepares a parameterized query string and list of parameters	 * 	 * for the query into a single QueryBuilder object	 */	private QueryBuilder prepareQueryforLicenses(	ArrayList<String> sArrDataInput, String projColumn,	boolean validFlag, String authorityType) {		LOG.debug("AuthorityService prepareQueryforLicenses() called.");		String joinString = "";		if (sArrDataInput.size() > 0)			joinString = sArrDataInput.get(0);							QueryBuilder qb = new QueryBuilder();		StringBuilder query = new StringBuilder(				"SELECT {0} FROM {1} {2}  {3}  WHERE  LCASE(TRIM({2}.{4}))=LCASE(TRIM(''{5}'')) AND ");		if (validFlag)			query.append(" LCASE(TRIM({6})) {7} {8} AND   {9} < current_date AND  {10} > current_date AND ");		Object[] tcArgs = { projColumn, prop.getProperty("table_au"),				prop.getProperty("alias_au"), getJoinString(joinString),				prop.getProperty("au_col_AuthorityType"),				prop.getProperty(authorityType),				prop.getProperty("au_col_LicenseStatus"), LICENSESQLOPERATOR,				LICENSESTATUS, prop.getProperty("au_col_StartDate"),				prop.getProperty("au_col_EndDate") };		/*		 * StringBuilder query = new StringBuilder(		 * 		 * "SELECT {0} FROM {1} {2}  LEFT OUTER JOIN {3} {4} ON {2}.{15}={4}.{16}    LEFT OUTER JOIN {5} {6} ON {2}.{15}={6}.{17} LEFT OUTER JOIN {7} {8} ON {2}.{15}={8}.{18} LEFT OUTER JOIN {9} {10} ON {2}.{15}={10}.{19} LEFT OUTER JOIN {11} {12} ON {2}.{15}={12}.{20} LEFT OUTER JOIN {13} {14} ON {2}.{21}={14}.{22}  WHERE  LCASE(TRIM({2}.{27}))=LCASE(TRIM(''{28}'')) AND "		 * );		 * 		 * if (validFlag)		 * 		 * query.append(		 * " LCASE(TRIM({23})) {29} {26} AND   {24} < current_date AND  {25} > current_date AND "		 * );		 * 		 * Object[] tcArgs = { projColumn, prop.getProperty("table_au"),		 * 		 * prop.getProperty("alias_au"), prop.getProperty("table_acm"),		 * 		 * prop.getProperty("alias_acm"), prop.getProperty("table_aim"),		 * 		 * prop.getProperty("alias_aim"), prop.getProperty("table_arm"),		 * 		 * prop.getProperty("alias_arm"), prop.getProperty("table_afsm"),		 * 		 * prop.getProperty("alias_afsm"), prop.getProperty("table_actm"),		 * 		 * prop.getProperty("alias_actm"), prop.getProperty("table_jcm"),		 * 		 * prop.getProperty("alias_jcm"),		 * 		 * prop.getProperty("au_col_AuthorityId"),		 * 		 * prop.getProperty("acm_col_AuthorityId"),		 * 		 * prop.getProperty("aim_col_AuthorityId"),		 * 		 * prop.getProperty("arm_col_AuthorityId"),		 * 		 * prop.getProperty("afsm_col_AuthorityId"),		 * 		 * prop.getProperty("actm_col_AuthorityId"),		 * 		 * prop.getProperty("au_col_JuCICode"),		 * 		 * prop.getProperty("jcm_col_JuCICode"),		 * 		 * prop.getProperty("table_aaum"), prop.getProperty("alias_aaum"),		 * 		 * prop.getProperty("aaum_col_AuthorityId"),		 * 		 * prop.getProperty("au_col_LicenseStatus"),		 * 		 * prop.getProperty("au_col_StartDate"),		 * 		 * prop.getProperty("au_col_EndDate"),		 * 		 * LICENSESTATUS, prop.getProperty("au_col_AuthorityType"),		 * prop.getProperty(authorityType), LICENSESQLOPERATOR };		 */		Iterator<String> iterator = sArrDataInput.iterator();		query.append(iterator.next());		while (iterator.hasNext()) {			qb.getQueryParameters().add(iterator.next());		}		qb.setPreparedQuery(MessageFormat.format(query.toString(), tcArgs));		// LOG.info(qb.getPreparedQuery());		return qb;	}	private String getJoinString(String predicates) {		StringBuffer jointQuery = new StringBuffer();		if (predicates != null) {			HashMap<String, String> aliasTableNameMapping = new HashMap<String, String>();			aliasTableNameMapping.put(prop.getProperty("alias_acm"),					prop.getProperty("table_acm"));			aliasTableNameMapping.put(prop.getProperty("alias_aim"),					prop.getProperty("table_aim"));			aliasTableNameMapping.put(prop.getProperty("alias_arm"),					prop.getProperty("table_arm"));			aliasTableNameMapping.put(prop.getProperty("alias_afsm"),					prop.getProperty("table_afsm"));			aliasTableNameMapping.put(prop.getProperty("alias_actm"),					prop.getProperty("table_actm"));			aliasTableNameMapping.put(prop.getProperty("alias_jcm"),					prop.getProperty("table_jcm"));			aliasTableNameMapping.put(prop.getProperty("alias_aaum"),					prop.getProperty("table_aaum"));			System.out.println(aliasTableNameMapping);			String joins = "LEFT OUTER JOIN {0} {1} ON {2}.{3}={1}.{4} ";			for (String key : aliasTableNameMapping.keySet()) {				if (predicates.contains(key + ".")) {					if (!key.equalsIgnoreCase(prop.getProperty("alias_jcm")))						jointQuery.append(MessageFormat.format(joins,								aliasTableNameMapping.get(key), key,								prop.getProperty("alias_au"),								prop.getProperty("au_col_AuthorityId"),								prop.getProperty(key + "_col_AuthorityId")));					else						jointQuery.append(MessageFormat.format(joins,								aliasTableNameMapping.get(key), key,								prop.getProperty("alias_au"),								prop.getProperty("au_col_JuCICode"),								prop.getProperty("jcm_col_JuCICode")));					System.out.println(jointQuery.toString());				}			}		}		return jointQuery.toString();	}	/*	 * 	 * 	 * 	 * Process the input data and put in arraylist od string	 */	private ArrayList<String> processValues(IEvalValue[] args) {		int i = 0;		ArrayList<String> sOutData = new ArrayList<String>();		for (IEvalValue ieValue : args) {			String sData = "";			if (null != ieValue) {				if (ieValue.equals(ValueType.NULL)) {					sOutData.add("-9999");					continue;				}				if (ieValue.getType() == ValueType.MULTIVAL) {					ArrayList<String> tempList = new ArrayList<String>();					IMultivalue mv = (IMultivalue) ieValue.getValue();					if (Multivalue.EMPTY == mv) {						sOutData.add("-9999");						continue;					}					for (Iterator<IEvalValue> it = mv.iterator(); it.hasNext();) {						IEvalValue ev = it.next();						if (ev.getType() == ValueType.STRING) {							if (!ev.getValue().toString().isEmpty()) {								sData = ev.getValue().toString();							}						} else if (ev.getType() == ValueType.LONG) {							sData = ev.getValue().toString();						} else if (ev.getType() == ValueType.DATE) {							sData = (String) ev.getValue().toString();						}						tempList.add(sData);					}					sOutData.add(UtilService.join(tempList, "','", "'", "'"));				} else if (ieValue.getType() == ValueType.STRING) {					sData = ieValue.getValue().toString();					sOutData.add(sData);				}				LOG.debug("----" + i + "." + sData + "-----");				// Filter out the empty string data				// if (sData.length()>0)			} else {				sOutData.add("-9999");			}			i++;		}		LOG.debug(sOutData);		return sOutData;	}	/**	 * 	 * For testing purpose	 * 	 * 	 * 	 * @param args	 */	public static void main(String[] args) throws Exception {		AuthorityService plugin = new AuthorityService();		plugin.init();		IEvalValue[] sDataArr1 = new IEvalValue[2];		sDataArr1[0] = EvalValue.build("1|2|3|4");		sDataArr1[1] = EvalValue.build("|");		ArrayList<String> evlist = new ArrayList<String>();		evlist.add("1");		evlist.add("2");		evlist.add("3");		IEvalValue[] sDataArr2 = new IEvalValue[3];		sDataArr2[0] = EvalValue.build("icy.qin");		sDataArr2[1] = EvalValue.build("CountryOfBirth");		sDataArr2[2] = EvalValue.build("US");		IEvalValue[] sDataArr = new IEvalValue[4];		sDataArr[0] = EvalValue				.build("(jcm.Jurisdiction in (?) OR jcm.classification in (?))");		IMultivalue val = Multivalue.create("ITAR", "EAR");		sDataArr[1] = EvalValue.build(val);		IMultivalue im = Multivalue.create(evlist, ValueType.STRING);		UserService us = new UserService();		us.init();		sDataArr[2] = EvalValue.build("V118.f");		// sDataArr[2] = EvalValue.build(im);		System.out.println(plugin.callFunction("getInternalLicenseNos",				sDataArr));	}}